{
"sessions": [{}
,{"start_time": "2024-07-20T20:49:22.450486-07:00", "end_time": "2024-07-20T22:31:17.609176-07:00", "start_message": "Begin session.", "end_message": "End session.\nMaking steady progress.", "messages": [{"time": "2024-07-20T20:49:22.450486-07:00", "msg": "Begin session."}, {"time": "2024-07-20T22:24:51.765048-07:00", "msg": "Right now, two `Symbol`s are equal if they are of the same class, same name and creation arguments."}, {"time": "2024-07-20T22:26:52.685375-07:00", "msg": "`main.py` ran without errors. Great success!"}, {"time": "2024-07-20T22:31:17.609176-07:00", "msg": "End session.\nMaking steady progress."}]}
,{"start_time": "2024-08-13T17:31:21.629176-07:00", "end_time": "2024-08-13T19:26:49.782819-07:00", "start_message": "Begin session.", "end_message": "End session.\nProved a simple theorem: real number 0 is unique", "messages": [{"time": "2024-08-13T17:31:21.629176-07:00", "msg": "Begin session."}, {"time": "2024-08-13T19:26:49.782819-07:00", "msg": "End session.\nProved a simple theorem: real number 0 is unique"}]}
,{"start_time": "2024-08-16T16:45:13.888728-07:00", "end_time": "2024-08-17T00:11:20.118816-07:00", "start_message": "Begin session.", "end_message": "End session.\nI've added a number of infix operators, fixed a few issues, added unification to `Expr` class. Pylance has a bug that does not allow assigning a generic function to a generic parameter in a class and being able to call that function normally, as I wanted to use with my @Infix decorator. Wrote the proof that 0 is unique using the infix proof style and I kinda like it.", "messages": [{"time": "2024-08-16T16:45:13.888728-07:00", "msg": "Begin session."}, {"time": "2024-08-16T16:57:29.571035-07:00", "msg": "I've started working on infix operator syntax such as `x |is_a| real_number`"}, {"time": "2024-08-17T00:11:20.118816-07:00", "msg": "End session.\nI've added a number of infix operators, fixed a few issues, added unification to `Expr` class. Pylance has a bug that does not allow assigning a generic function to a generic parameter in a class and being able to call that function normally, as I wanted to use with my @Infix decorator. Wrote the proof that 0 is unique using the infix proof style and I kinda like it."}]}
,{"start_time": "2024-08-17T09:58:29.665015-07:00", "end_time": "2024-08-17T15:30:32.531396-07:00", "start_message": "Begin session.", "end_message": "End session.\nTaking a break. Working on Groups; need to check that the group operation is associative. I'm thinking I might need to remove the Set class and just have Symbol; it would have attributes accessible depending on if 'is_set' is True.", "messages": [{"time": "2024-08-17T09:58:29.665015-07:00", "msg": "Begin session."}, {"time": "2024-08-17T15:30:32.531396-07:00", "msg": "End session.\nTaking a break. Working on Groups; need to check that the group operation is associative. I'm thinking I might need to remove the Set class and just have Symbol; it would have attributes accessible depending on if 'is_set' is True."}]}
,{"start_time": "2024-08-18T09:08:51.042660-07:00", "end_time": "2024-08-18T09:53:27.702205-07:00", "start_message": "Begin session.", "end_message": "End session.\nImplemented magma; need to start thinking about testing", "messages": [{"time": "2024-08-18T09:08:51.042660-07:00", "msg": "Begin session."}, {"time": "2024-08-18T09:53:27.702205-07:00", "msg": "End session.\nImplemented magma; need to start thinking about testing"}]}
,{"start_time": "2024-08-18T11:43:47.351390-07:00", "end_time": "2024-08-18T15:45:41.520273-07:00", "start_message": "Begin session.", "end_message": "End session.\nImplemented monoid and quasigroup.", "messages": [{"time": "2024-08-18T11:43:47.351390-07:00", "msg": "Begin session."}, {"time": "2024-08-18T15:45:41.520273-07:00", "msg": "End session.\nImplemented monoid and quasigroup."}]}
,{"start_time": "2024-08-18T16:08:18.321126-07:00", "end_time": "2024-08-19T01:14:21.758157-07:00", "start_message": "Begin session.", "end_message": "End session.\nfixed bugs, added util functions, proved that group elements have unique inverses ", "messages": [{"time": "2024-08-18T16:08:18.321126-07:00", "msg": "Begin session."}, {"time": "2024-08-18T17:39:11.704253-07:00", "msg": "Done with `AbelianGroup`. Will skip Semilattic for now."}, {"time": "2024-08-19T01:13:37.806188-07:00", "msg": "I just finished proving that group elements have unique inverses from their axioms."}, {"time": "2024-08-19T01:14:21.758157-07:00", "msg": "End session.\nfixed bugs, added util functions, proved that group elements have unique inverses "}]}
,{"start_time": "2024-08-25T12:56:06.647839-07:00", "end_time": "2024-08-25T17:36:35.640553-07:00", "start_message": "Begin session.", "end_message": "End session.\nbreak session", "messages": [{"time": "2024-08-25T12:56:06.647839-07:00", "msg": "Begin session."}, {"time": "2024-08-25T17:36:11.240974-07:00", "msg": "Started implementing ring-like structures. Need to implement `CrookedSemirIng`, `SemirIng`, `Rng` and `RIng`."}, {"time": "2024-08-25T17:36:35.640553-07:00", "msg": "End session.\nbreak session"}]}
,{"start_time": "2024-08-25T21:38:58.883671-07:00", "end_time": "2024-08-25T21:40:08.915607-07:00", "start_message": "Begin session.", "end_message": "End session.\nimplemented ring-like all the way to `Ring`.", "messages": [{"time": "2024-08-25T21:38:58.883671-07:00", "msg": "Begin session."}, {"time": "2024-08-25T21:39:45.093519-07:00", "msg": "had another >2 hr session, just ended. Had an error in session.py. I implemented ring-like all the way to `Ring`."}, {"time": "2024-08-25T21:40:08.915607-07:00", "msg": "End session.\nimplemented ring-like all the way to `Ring`."}]}
,{"start_time": "2024-08-26T17:31:31.582383-07:00", "end_time": "2024-08-26T21:47:20.519194-07:00", "start_message": "Begin session.", "end_message": "End session.\nEnd session. Implemented and tested (a bit) Field.", "messages": [{"time": "2024-08-26T17:31:31.582383-07:00", "msg": "Begin session."}, {"time": "2024-08-26T19:30:23.618517-07:00", "msg": "implemented `Field`."}, {"time": "2024-08-26T21:46:40.949419-07:00", "msg": "I've done some basic tests with a `Field` instance.\nI need to make it so that if an Expr or object is the result of a operation\nused in defining the structure, the set automatically contains it.\n\nFor eg, right now, using `plus_operation=lambda x,y: Add(x,y)` results in not being able\nto tell if `Add(x,y)` is an element of the set, but it should be.\n\nOn a related note, need to create `_is_real` and `_is_natural` etc attributes\non `Symbol`s and `Expr`s, and then `is_real = _is_real or is_rational`\n`is_rational = _is_rational or is_natural`, `is_natural = _is_natural`.\nThese can be `True`, `False` or `None`.\n\nFinally, add functionality to convert `Sympy` -> `Pylogic`."}, {"time": "2024-08-26T21:47:20.519194-07:00", "msg": "End session.\nEnd session. Implemented and tested (a bit) Field."}]}
,{"start_time": "2024-08-27T19:23:13.950456-07:00", "end_time": "2024-08-27T23:33:15.998891-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session.", "messages": [{"time": "2024-08-27T19:23:13.950456-07:00", "msg": "Begin session."}, {"time": "2024-08-27T23:31:08.940103-07:00", "msg": "I separated `evaluate` and `to_sympy`. `evaluate` still gives an `Expr` or `Symbol`, while `to_sympy` gives a corresponding\nsympy object.\n\nAlso added generics to Binary relations. Now we can tell the type of the left and right sides (still need to add the type arguments everywhere they are used)"}, {"time": "2024-08-27T23:33:06.922771-07:00", "msg": "So in total I added predicates to sets, added the sympy conversion functions and fixed some type issues.\nAlso add elements that are results of Magma operations to the Magma set."}, {"time": "2024-08-27T23:33:15.998891-07:00", "msg": "End session.\nend session."}]}
,{"start_time": "2024-08-28T10:23:11.833569-07:00", "end_time": "2024-08-28T22:51:01.953473-07:00", "start_message": "Begin session.", "end_message": "End session.\n sets can now be used in expressions (to implement union, intersect etc); implement has_as_subproposition, implement Class{n}, Set==Class0 and Collection[Class[n]]", "messages": [{"time": "2024-08-28T10:23:11.833569-07:00", "msg": "Begin session."}, {"time": "2024-08-28T21:39:34.170777-07:00", "msg": "I have a feeling about how python's `__init__` and `__new__` interact:\n\n- code calls `__new__` first and saves the result\n- code calls `__init__` with the same arguments\n- code returns the result of `__new__`.\n\nI haven't looked at this recently but I'm having a small issue with it right now."}, {"time": "2024-08-28T22:51:01.953473-07:00", "msg": "End session.\n sets can now be used in expressions (to implement union, intersect etc); implement has_as_subproposition, implement Class{n}, Set==Class0 and Collection[Class[n]]"}]}
,{"start_time": "2024-08-30T17:50:15.664601-07:00", "end_time": "2024-08-30T21:59:35.389171-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session.", "messages": [{"time": "2024-08-30T17:50:15.664601-07:00", "msg": "Begin session."}, {"time": "2024-08-30T21:59:17.703732-07:00", "msg": "fix some type issues; introduce `TotalOrder`, `PartialOrder`, etc. Need to add some more axioms to ordered field, ie how order interacts with field operations. Also, I will use the `StrictTotalOrder` to define the reals."}, {"time": "2024-08-30T21:59:35.389171-07:00", "msg": "End session.\nend session."}]}
,{"start_time": "2024-08-31T19:22:51.411432-07:00", "end_time": "2024-08-31T23:15:22.213187-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session", "messages": [{"time": "2024-08-31T19:22:51.411432-07:00", "msg": "Begin session."}, {"time": "2024-08-31T23:07:11.676150-07:00", "msg": "Ran into an issue. Currently, in `copy` for each proposition, I use a deepcopy style where I copy every subproposition.\n\nThis method is used a lot with tactics when proving. However, when proving theorems of structures in their `__init__`,\nthis often results in trying to copy `self` since the theorems refer to the same object.\n\nThis leads to a recursion error since it calls `self.__class__.__init__` forever. Therefore, I will move to using shallow copy\nfor the `copy` methods for tactics. I will keep the `deepcopy` as an option when needed. Need to work on this the coming week."}, {"time": "2024-08-31T23:15:22.213187-07:00", "msg": "End session.\nend session"}]}
,{"start_time": "2024-09-06T19:30:01.235107-07:00", "end_time": "2024-09-06T21:02:49.690140-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session", "messages": [{"time": "2024-09-06T19:30:01.235107-07:00", "msg": "Begin session."}, {"time": "2024-09-06T21:01:50.563532-07:00", "msg": "Still need to fix `deepcopy` and add `copy` to:\n\n- forall\n- quantified\n- binaryrelation\n- contains\n- equals\n- relation\n- subsets\n- class_\n- set_"}, {"time": "2024-09-06T21:02:49.690140-07:00", "msg": "End session.\nend session"}]}
,{"start_time": "2024-09-07T17:03:00.723331-07:00", "end_time": "2024-09-07T20:14:01.956683-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session", "messages": [{"time": "2024-09-07T17:03:00.723331-07:00", "msg": "Begin session."}, {"time": "2024-09-07T20:13:56.613792-07:00", "msg": "finish deepcopy for remining classes; modify order types and prove irreflexive for ordered field."}, {"time": "2024-09-07T20:14:01.956683-07:00", "msg": "End session.\nend session"}]}
,{"start_time": "2024-09-08T18:42:11.886381-07:00", "end_time": "2024-09-08T23:20:33.813307-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session", "messages": [{"time": "2024-09-08T18:42:11.886381-07:00", "msg": "Begin session."}, {"time": "2024-09-08T23:20:13.189675-07:00", "msg": "add `try_except` function; modify `find_first`;\n\nadd `to_exor` to `And`;\n\nadd `one_proven`, `one_proven_rem_false` to `ExOr`;\n\n`first_unit_def_clause_resolve` to `And`; `symmetric` to `Not`;\n\nfix `and_`; fix `ForallInSet` in_particular;\n\nprove strict order is asymmetric in `OrderedField`. Need to modify definition of order to use xor: `a <= b iff (a < b xor a = b)`"}, {"time": "2024-09-08T23:20:33.813307-07:00", "msg": "End session.\nend session"}]}
,{"start_time": "2024-09-09T16:11:34.180530-07:00", "end_time": "2024-09-09T20:19:53.626148-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session", "messages": [{"time": "2024-09-09T16:11:34.180530-07:00", "msg": "Begin session."}, {"time": "2024-09-09T16:32:09.910606-07:00", "msg": "realised I need methods to expand with `_junction` propositions eg `(a and b) or c |= (a or c) and (b or c)`.\n\nAnother tactic will be the ability to rewrite some part of the proposition tree into an equivalent proposition.\nI wil need to mark which tactics are \"equivalences\" for this."}, {"time": "2024-09-09T16:55:50.368317-07:00", "msg": "`And` distributes over `ExOr`, but `ExOr` does not distribute over `And`."}, {"time": "2024-09-09T19:48:51.867287-07:00", "msg": "I thought about the \"tactics\" for which I need to check if proven and those I don't:\n\nIf the relationship is an equivalence, I don't need to check if `self.is_proven` for e.g.,\notherwise if it's an implication/entailment, I need to check if `self.is_proven` to make the deduction work.\n\nTODO: remove `p_and`, `p_or`, etc."}, {"time": "2024-09-09T19:53:24.485526-07:00", "msg": "I noticed a few type features I need in Python's typing. One is better TypevarTuple support: Union of TypeVarTuples etc.\n\nAnother is generics of generics. Something like\n\n```python\nT = TypeVar(...)\nU = TypeVar(...)\n\ndef method(x: T[U]):\n\treturn ...\n```\nThis way I can return the exact type I need.\n\nA similar one is making something like `Self` but generic, e.g.\n\n```python\n\nclass B(A[T, U]):\n\tdef method(self, x) -> SameClass[U, T]:\n\t\treturn ...\n```"}, {"time": "2024-09-09T20:19:46.844938-07:00", "msg": "add left_distribute, right_distribute for `_Junction`; `de_nest`; `by_cases`; proved `strict_order_transitive` (just by definition tho) and `connected`"}, {"time": "2024-09-09T20:19:53.626148-07:00", "msg": "End session.\nend session"}]}
,{"start_time": "2024-09-11T06:59:11.711341-07:00", "end_time": "2024-09-11T07:00:20.333104-07:00", "start_message": "Begin session.", "end_message": "End session.\nend", "messages": [{"time": "2024-09-11T06:59:11.711341-07:00", "msg": "Begin session."}, {"time": "2024-09-11T07:00:15.769328-07:00", "msg": "I had a session of slightly less than 12hrs yesterday, but I turned off computer before documenting. Will update later today."}, {"time": "2024-09-11T07:00:20.333104-07:00", "msg": "End session.\nend"}]}
,{"start_time": "2024-09-18T15:25:05.026006-07:00", "end_time": "2024-09-18T15:29:41.593000-07:00", "start_message": "Begin session.", "end_message": "End session.\nbreak session", "messages": [{"time": "2024-09-18T15:25:05.026006-07:00", "msg": "Begin session."}, {"time": "2024-09-18T15:29:41.593000-07:00", "msg": "End session.\nbreak session"}]}
,{"start_time": "2024-09-18T15:32:15.026564-07:00", "end_time": "2024-09-18T18:32:24.157341-07:00", "start_message": "Begin session.", "end_message": "End session.\ndenest for constant; modify __eq__ for constant and symbol; add .variables, .constants, .class_ns to props and exprs;introduce dependencies for vars; fix extract, thus_forall to remove logical inconstistency (see Screenshot_20240918_182440_Samsung_Notes.jpg)", "messages": [{"time": "2024-09-18T15:32:15.026564-07:00", "msg": "Begin session."}, {"time": "2024-09-18T18:32:24.157341-07:00", "msg": "End session.\ndenest for constant; modify __eq__ for constant and symbol; add .variables, .constants, .class_ns to props and exprs;introduce dependencies for vars; fix extract, thus_forall to remove logical inconstistency (see Screenshot_20240918_182440_Samsung_Notes.jpg)"}]}
,{"start_time": "2024-09-20T15:04:44.922136-07:00", "end_time": "2024-09-20T17:11:28.920894-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session", "messages": [{"time": "2024-09-20T15:04:44.922136-07:00", "msg": "Begin session."}, {"time": "2024-09-20T17:11:18.324391-07:00", "msg": "fix bugs of not add equal_check; add existsSubset, existsUniqueSubset and ForallSubsets; fix Forall call to be in the right place; rename Subset to IsSubsetOfadd last 2 axioms of orderedField (need to prove some theorems of inequalities); add structure of bounded_above axiom for RealsField"}, {"time": "2024-09-20T17:11:28.920894-07:00", "msg": "End session.\nend session"}]}
,{"start_time": "2024-09-26T15:32:59.649827-07:00", "end_time": "2024-09-26T17:12:18.595776-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session", "messages": [{"time": "2024-09-26T15:32:59.649827-07:00", "msg": "Begin session."}, {"time": "2024-09-26T17:11:53.465704-07:00", "msg": "add by_empty tactic; add is_subset_of method; add completeness axiom for RealsField; The latex can be confusing so I need to define a proper order of operations to reduce parentheses in printing and latex displays."}, {"time": "2024-09-26T17:12:18.595776-07:00", "msg": "End session.\nend session"}]}
,{"start_time": "2024-09-26T17:18:07.857197-07:00", "end_time": "2024-09-26T17:29:38.784932-07:00", "start_message": "Begin session.", "end_message": "End session.\ndraft for order of operations", "messages": [{"time": "2024-09-26T17:18:07.857197-07:00", "msg": "Begin session."}, {"time": "2024-09-26T17:29:15.494339-07:00", "msg": "Starting to sketch what the order of operations/symbols should be for Proposition\n\nHigher operations (at the top) bind more tightly\n\n1. Not\n2. Quantifiers\n3. Conjunction\n4. Disjunction\n5. ExOr\n6. Implication\n7. Iff\n\nand for Expressions & Relations\n\n1. Pow\n2. Mul\n3. Add\n4. Custom expressions\n5. Relations(eg <, subset), Propositions\n\nso\n\nforall x: P(x) and Q(y) -> R(z) <-> W(q)\n\nis equivalent to (((forall x: P(x)) and Q(y)) -> R(z)) <-> W(q)\n\nwhile \n\nA xor B and forall x: C -> D or E <-> F\n\nis the same as\n\n((A xor (B and (forall x: C))) -> (D or E)) <-> F\n\n\n"}, {"time": "2024-09-26T17:29:38.784932-07:00", "msg": "End session.\ndraft for order of operations"}]}
,{"start_time": "2024-09-27T15:31:12.763868-07:00", "end_time": "2024-09-27T15:48:42.931714-07:00", "start_message": "Begin session.", "end_message": "End session.\nbreak session", "messages": [{"time": "2024-09-27T15:31:12.763868-07:00", "msg": "Begin session."}, {"time": "2024-09-27T15:48:32.926393-07:00", "msg": "need to add proposition types\n\n\"x is of the form f(a,b,c)\"\n\"forall x of the form f(a,b,c), ...\" (a,b,c are independent variables I think)\n\nand be able to define sets as\n\n{f(a,b,c) | a in S}  <-> \"Set of all x of the form f(a,b,c) where a in S\"\n"}, {"time": "2024-09-27T15:48:42.931714-07:00", "msg": "End session.\nbreak session"}]}
,{"start_time": "2024-10-03T16:42:55.501602-07:00", "end_time": "2024-10-03T17:17:12.353742-07:00", "start_message": "Begin session.", "end_message": "End session.\nbreak session", "messages": [{"time": "2024-10-03T16:42:55.501602-07:00", "msg": "Begin session."}, {"time": "2024-10-03T16:43:33.873966-07:00", "msg": "I started the session around 3:30pm, but forgot to login here."}, {"time": "2024-10-03T17:17:01.195583-07:00", "msg": "I've moved Term types to one place, currently looking at https://docs.sympy.org/latest/modules/series/sequences.html for inspiration to define sequences.\n\nThen I can define countable unions and intersections using sequences of sets"}, {"time": "2024-10-03T17:17:12.353742-07:00", "msg": "End session.\nbreak session"}]}
,{"start_time": "2024-10-03T17:50:08.368833-07:00", "end_time": "2024-10-03T21:02:16.653080-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session", "messages": [{"time": "2024-10-03T17:50:08.368833-07:00", "msg": "Begin session."}, {"time": "2024-10-03T20:54:15.599845-07:00", "msg": "Currently working on completing definitions for countable and finite unions and intersections.\nOnce done, I'll work on set difference.\n\nThen define rationals, integers, naturals0 and naturals.\n\nFrom there, I'll start proving theorems of real numbers."}, {"time": "2024-10-03T21:02:05.547197-07:00", "msg": "move Term,Numeric etc to pylogic; add casting methods to Constant; add thus_contained_in_at_least_one and thus_contained_in_all for IsContainedIn union and intersection; add by_inspection for Equals; add FiniteSet, Union, FiniteUnion, need to correct FiniteIntersection; add Interval; add sequence and subtypes, add their conversions in sympy_to_pylogic"}, {"time": "2024-10-03T21:02:16.653080-07:00", "msg": "End session.\nend session"}]}
,{"start_time": "2024-10-09T14:03:54.545874-07:00", "end_time": "2024-10-09T15:57:26.448725-07:00", "start_message": "Begin session.", "end_message": "End session.\nbreak session", "messages": [{"time": "2024-10-09T14:03:54.545874-07:00", "msg": "Begin session."}, {"time": "2024-10-09T14:04:29.327333-07:00", "msg": "started session about 20 minutes ago."}, {"time": "2024-10-09T15:57:18.423041-07:00", "msg": "Currently trying to define empty cartesian product of sets; after looking online,\nlooks like it is {{}}, so I will define this set as a special singleton set\nand use it in definitions/evaluations for product of sets."}, {"time": "2024-10-09T15:57:26.448725-07:00", "msg": "End session.\nbreak session"}]}
,{"start_time": "2024-10-11T19:51:15.152037-07:00", "end_time": "2024-10-11T20:01:09.484205-07:00", "start_message": "Begin session.", "end_message": "End session.\nbreak session.", "messages": [{"time": "2024-10-11T19:51:15.152037-07:00", "msg": "Begin session."}, {"time": "2024-10-11T20:01:09.484205-07:00", "msg": "End session.\nbreak session."}]}
,{"start_time": "2024-10-11T20:43:08.877947-07:00", "end_time": "2024-10-11T22:28:04.345915-07:00", "start_message": "Begin session.", "end_message": "End session.\nbreak session.", "messages": [{"time": "2024-10-11T20:43:08.877947-07:00", "msg": "Begin session."}, {"time": "2024-10-11T20:43:37.518495-07:00", "msg": "session started ~ 20 mins ago."}, {"time": "2024-10-11T22:28:04.345915-07:00", "msg": "End session.\nbreak session."}]}
,{"start_time": "2024-10-12T14:59:13.661385-07:00", "end_time": "2024-10-12T16:22:12.147474-07:00", "start_message": "Begin session.", "end_message": "End session.\nbreak session.", "messages": [{"time": "2024-10-12T14:59:13.661385-07:00", "msg": "Begin session."}, {"time": "2024-10-12T16:22:03.615704-07:00", "msg": "I'm currently trying to define replace, copy etc for piecewise expressions and piecewise branches. Once done, I'll define recursive functions and functions in general, then start working on natural numbers."}, {"time": "2024-10-12T16:22:12.147474-07:00", "msg": "End session.\nbreak session."}]}
,{"start_time": "2024-10-13T18:06:17.660850-07:00", "end_time": "2024-10-14T02:46:29.551757-07:00", "start_message": "Begin session.", "end_message": "End session.\nend session", "messages": [{"time": "2024-10-13T18:06:17.660850-07:00", "msg": "Begin session."}, {"time": "2024-10-13T18:06:38.713371-07:00", "msg": "Started a while ago. At least 2 hrs ago."}, {"time": "2024-10-13T22:00:48.775150-07:00", "msg": "I discovered a flaw in my thinking.\n\nThe boolean xor operation says \"an odd number of args is True => entire is True\",\n\"an even number of args is True => entire is False\", for a general number of args\n\nThis is different from \"exactly one arg is True => entire is True, otherwise entire is False\", for a general number of args, which is what I've been doing.\n\nI need to come up with a proper definition of exor for use in my head. Thankfully, I haven't added methods like \"to_conjunction_disjunction\" converting an exor to something it shouldn't be.\nI want to keep my definition, because it is useful.\n\nAfter some thinking, I discovered the formula I need for my exor.\n\nExOr(Ai, all i) = A1 xor A2 xor ... := Disjunction(Ai, all i)  and  Conjunction(not(Ai) or not(Aj), i!=j).\n\nwhere Disjunction(...) and Conjunction(...) contain sequences of propositions."}, {"time": "2024-10-13T22:47:57.961740-07:00", "msg": "I think I properly reminded myself that A and B === A does not imply B === True. In particular,\nIf A is False, B can be True or False and the whole thing is False.\n\nAs an example,\n\nA and (A or C).\n\nWhen A is True, the entire is True, and when A is False, the entire is False.\n"}, {"time": "2024-10-14T02:46:22.463402-07:00", "msg": "I need to fix and test out some more things with recursive functions eg evaluations\n\nBut I'll soon start writing code for Natural numbers."}, {"time": "2024-10-14T02:46:29.551757-07:00", "msg": "End session.\nend session"}]}
,{"start_time": "2024-10-14T14:03:15.056199-07:00", "end_time": "2024-10-15T01:07:18.147982-07:00", "start_message": "Begin session.", "end_message": "End session.\nI need to take a step back and look at the real analysis theorems that I would like to prove and work on those; But I do need to define rational numbers next.", "messages": [{"time": "2024-10-14T14:03:15.056199-07:00", "msg": "Begin session."}, {"time": "2024-10-15T00:21:56.129396-07:00", "msg": "I learned something new: `__eq__` should return `NotImplemented` when there is not default comparison, rather than False, so that the reverse comparison can be tried."}, {"time": "2024-10-15T01:07:18.147982-07:00", "msg": "End session.\nI need to take a step back and look at the real analysis theorems that I would like to prove and work on those; But I do need to define rational numbers next."}]}
,{"start_time": "2024-10-15T15:46:12.347977-07:00", "end_time": "2024-10-16T07:52:32.584915-07:00", "start_message": "Begin session.", "end_message": "End session.\nend", "messages": [{"time": "2024-10-15T15:46:12.347977-07:00", "msg": "Begin session."}, {"time": "2024-10-16T02:13:01.003618-07:00", "msg": "possible demo\n## Small proof that x in I2 implies x in I1\n# I1 = I[1]\n# I2 = I[2]\n# x_in_I2 = x.is_in(I2).assume()\n# I1_eval = I1.evaluate()\n# I2_eval = I2.evaluate()\n# step0 = I1.equals(I1_eval).by_simplification()\n# step1 = I2.equals(I2_eval).by_simplification()\n# step2 = x_in_I2.substitute(\"right\", step1)\n# x_in_reals, a2_leq_x, x_leq_b2 = step2.thus_predicate().extract()\n\n# a1_p_1_eq_a2 = a[one + one].equals(a[2]).by_simplification()\n# a1_leq_a2 = a.predicate(1)[1].substitute(\"right\", a1_p_1_eq_a2)\n\n# b1_p_1_eq_b2 = b[one + one].equals(b[2]).by_simplification()\n# b2_leq_b1 = b.predicate(1)[1].substitute(\"right\", b1_p_1_eq_b2)\n\n# a1_leq_x = a1_leq_a2.transitive(a2_leq_x)\n# x_leq_b1 = x_leq_b2.transitive(b2_leq_b1)\n\n\n# x_in_I1_eval = x.is_in(I1_eval).by_predicate(x_in_reals.p_and(a1_leq_x, x_leq_b1))\n# x_in_I1 = x_in_I1_eval.substitute(\"left\", step0)\n# print(x_in_I1)"}, {"time": "2024-10-16T07:52:23.811876-07:00", "msg": "Besides my class, I've really been on this all day and night. I'm done for now, but there are some bugs and issues to fix. Currently, I have a proof of n*(n+1) is even, and a proof of the nested interval property."}, {"time": "2024-10-16T07:52:32.584915-07:00", "msg": "End session.\nend"}]}
,{"start_time": "2024-10-20T21:33:24.918166-07:00", "end_time": "2024-10-21T01:03:44.600691-07:00", "start_message": "Begin session.", "end_message": "End session.\nI added assumptions_context to get rid of followed_from (and thus_forall) and some bugs that come with it. (e.g when one assumption proves multiple conclusions but we only call followed_from from one conclusion). WIll commit later.", "messages": [{"time": "2024-10-20T21:33:24.918166-07:00", "msg": "Begin session."}, {"time": "2024-10-21T01:03:44.600691-07:00", "msg": "End session.\nI added assumptions_context to get rid of followed_from (and thus_forall) and some bugs that come with it. (e.g when one assumption proves multiple conclusions but we only call followed_from from one conclusion). WIll commit later."}]}
,{"start_time": "2024-10-29T16:52:44.952777-07:00", "end_time": "2024-10-29T21:24:57.802821-07:00", "start_message": "Begin session.", "end_message": "End session.\nremove .set_ from IsContainedIn in favor of .right; remove thus_forall_in_set (need to remove followed_from) and added AssumptionsCOntext; fix repr, str and latex for multiple types to use implicit parentheses (need to add option for explicit parentheses); added order of operations for parentheses; add is_countable (need to make it say 'exists seq in class_of_seqs, s = SeqSet(seq)'. TODO: latex and str for Product and Sum", "messages": [{"time": "2024-10-29T16:52:44.952777-07:00", "msg": "Begin session."}, {"time": "2024-10-29T16:53:19.872954-07:00", "msg": "I think I didn't record yesterday's session, but I worked on adding SeqSet and a few fixes."}, {"time": "2024-10-29T21:24:57.802821-07:00", "msg": "End session.\nremove .set_ from IsContainedIn in favor of .right; remove thus_forall_in_set (need to remove followed_from) and added AssumptionsCOntext; fix repr, str and latex for multiple types to use implicit parentheses (need to add option for explicit parentheses); added order of operations for parentheses; add is_countable (need to make it say 'exists seq in class_of_seqs, s = SeqSet(seq)'. TODO: latex and str for Product and Sum"}]}
,{"start_time": "2024-11-01T17:50:05.913142-07:00", "end_time": "2024-11-02T00:27:46.818047-07:00", "start_message": "Begin session.", "end_message": "End session.\nbreak session. I'll come back and start writing a new demo in form of blog/tutorial.", "messages": [{"time": "2024-11-01T17:50:05.913142-07:00", "msg": "Begin session."}, {"time": "2024-11-01T17:50:23.921270-07:00", "msg": "Session started up to 1 hr ago but crashed."}, {"time": "2024-11-02T00:27:12.845432-07:00", "msg": "The terms are:\n\n1. Expression\n2. Symbol: Constant and Variable\n3. Set\n4. Sequence\n\nThe atomic terms are\n\n1. Symbol\n2. Set\n3. Sequence\n5. SequenceTerm (its unevaluated)\n\nThe propositions are\n\n1. Proposition\n2. \\_Junction: And, Or, ExOr\n3. Relation: BinaryRelation, Ordering, etc\n4. Implies\n5. Iff\n6. Not\n7. Quantified:\n- Forall, etc\n- Exists, etc\n\n"}, {"time": "2024-11-02T00:27:46.818047-07:00", "msg": "End session.\nbreak session. I'll come back and start writing a new demo in form of blog/tutorial."}]}
,{"start_time": "2024-11-04T13:58:13.775001-08:00", "end_time": "2024-11-04T14:50:29.842378-08:00", "start_message": "Begin session.", "end_message": "End session.\nI'm currently defining limit. break session.", "messages": [{"time": "2024-11-04T13:58:13.775001-08:00", "msg": "Begin session."}, {"time": "2024-11-04T14:50:29.842378-08:00", "msg": "End session.\nI'm currently defining limit. break session."}]}
]}